<h1>The Righteous Markup Lever</h1>
<i>v1.4.0</i>

<h2>What's New?</h2>

<h3>The Siblings Method</h3>

<p>To abstract out the common pattern of joining string arrays or using <code>+=</code>, 
	you can now call <code>RML.siblings()</code> with any number of arguments:</p>

<pre>
RML.ul({
    id: 'list',
    content: RML.siblings(
		RML.li('these'),
		RML.li('are'),
		RML.li('sibling'),
		RML.li('elements')
});
</pre>

<h3>Use of _class</h3>

<p>A workaround for the fact that 'class' is a reserved keyword, when you are placing a class attribute
	on an element with RML use '_class: "name"'. The underscore will get stripped off and 'class' 
	written in its place, this way you won't get parsing errors or warnings from JSLint (if you use it) 
	See below:</p>
	
<pre>
RML.div({
	id: 'foo',
	_class: 'bar',
	content: function() {
		return 'if your content attribute is a function RML will call it for you';
	}
});
</pre>

<h3>Node.js Module</h3>
<p>
I made a Node compatible version of RML, it's in the 'rml' folder above. The 
folder contains the single file 'index.js' so you can just reference the directory
with your Node require statement. I created a '.node_libraries' folder in my home 
directory, and I simlink files to it as node will look there to resolve 'requires' 
statements. For example:

<pre>
	$ln -s ~/path-to-rml-folder ~/.node_libraries/rml	
</pre>

Then in your Node file or REPL session:

<pre>
	var RML = require('rml');	
</pre>

All other use is identical to client-side version. I have been using RML with
<a href="http://github.com/visionmedia/express">express</a> so I don't have to 
write HTML into the response:

<pre>
get('/update', function(req, res){
	res.send(
		RML.div({
			id: 'foo',
			_class: 'padded',
			content: RML.p('some content')
		})
	);
});
</pre>
</p>

<h3>The Tags Object</h3>

<p>This version says goodbye to the hard-coded convenience methods and now dynamically creates them based on the key-value pairs in the 'tags' object.

<pre>
tags: {
    'a': false,
    'br': true
}
</pre>

At run-time these are convered into convenience methods for each property defined. For example the <code>br: true</code> above is appended to the RML object as:
<pre>
br: function(arg) {
	this.tag('br', arg, true);
}
</pre>

The 'key' is obviously the tag name followed by a bool which will be supplied as the isClosed argument. Just include any tags you want appended to the RML object as convenience methods here.</p>

<p>This does mean that the tag attributes could be completely nonsense, e.g. <code>foo="bar"</code> but hey, if you want a tag with those properties RML shouldn't stop you right?</p>

<h3>Misc. Examples</h3>

<p>Say you had a 'markup' object which held all of your HTML generating methods:</p>

<pre>
markup: {
	header: function() {
    	var $header = RML.div({
        	id:'header',
        	content: RML.siblings( 
				RML.h1('An H1'),
				RML.hr(),
				RML.div({
          			_class:'message-form',
          			content: RML.textarea({
          				name:'txt-message',
          				id:'txt-message',
          				rows:'4',
          				cols:'60'
        		}),
				RML.input({
          			type:'button',
          			id:'btn-send-message',
          			name:'btn-send-message',
          			value:'Send Message'
        		}),
 				RML.input({
          			type:'button',
          			id:'btn-clear-message',
          			name:'btn-clear-message',
          			value:'Clear Message'
        		}),
				RML.input({
          			type:'button',
          			id:'btn-logout',
          			name:'btn-logout',
          			value:'Log Out'
        		})
      		})
    	});
    	return $header;
	},
	footer: function() {...}
};
</pre>

<h4>Custom, XML, or HTML5 tags</h4>

<p>Tags not defined by you (or me) in the tags object can be generated in your scripts by simply calling RML.tag() directly:

<pre>RML.tag('myTag', 'stuff', false)</pre>

The 'isClosed' bool sent as true will generate a self closing tag:

<pre>RML.tag('custom', {foo:'bar'}, true)</pre>

Any attributes without values can be placed in a tag by simply leaving the value a blank string:

<pre>RML.tag('custom', {keyOnly:''}, false)</pre>

Would yield a tag <pre>&lt custom keyOnly&gt&lt/custom&gt</pre>

enjoy.</p>
